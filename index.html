<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyprus Water Levels | Real-time Reservoir Dashboard</title>
    <meta name="description" content="Real-time dashboard monitoring water reservoir levels, dam capacities, and daily inflows in Cyprus. View historical trends and current water security data.">
    <meta name="keywords" content="Cyprus water, reservoir levels, dam capacity, water storage, Cyprus drought, water inflow, Kouris dam">
    <meta name="author" content="e1+">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Cyprus Water Levels | Real-time Reservoir Dashboard">
    <meta property="og:description" content="Real-time dashboard monitoring water reservoir levels, dam capacities, and daily inflows in Cyprus.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="Cyprus Water Levels | Real-time Reservoir Dashboard">
    <meta property="twitter:description" content="Real-time dashboard monitoring water reservoir levels, dam capacities, and daily inflows in Cyprus.">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="bg-blue-50 text-slate-800 min-h-screen">

    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Header -->
        <header class="mb-8 text-center sm:text-left">
            <h1 class="text-3xl font-bold text-blue-900 mb-2">Cyprus Water Reservoirs</h1>
            <p class="text-blue-600">Real-time water level monitoring dashboard</p>
            <p class="text-xs text-gray-500 mt-1">* MCM = Million Cubic Meters</p>
        </header>

        <!-- Loading State -->
        <div id="loading" class="flex flex-col items-center justify-center py-20">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
            <p class="text-blue-500 font-medium">Loading water data...</p>
        </div>

        <!-- Error State -->
        <div id="error" class="hidden bg-red-50 border border-red-200 text-red-700 px-6 py-4 rounded-lg mb-8 text-center shadow-sm">
            <p id="error-message">Unable to fetch data. Please try again later.</p>
            <button onclick="window.location.reload()" class="mt-2 text-sm font-semibold underline hover:text-red-800">Retry</button>
        </div>

        <!-- Dashboard Content -->
        <div id="dashboard" class="hidden fade-in space-y-8">
            <!-- Stats Grid -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- Latest Percentage Card -->
                <div class="bg-white rounded-xl shadow-sm border border-blue-100 p-6 flex items-center space-x-4">
                    <div class="p-3 bg-blue-100 rounded-full text-blue-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
                        </svg>
                    </div>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Current Capacity</p>
                        <h2 id="current-percentage" class="text-3xl font-bold text-gray-900">--%</h2>
                    </div>
                </div>

                <!-- Total Capacity Card -->
                <div class="bg-white rounded-xl shadow-sm border border-blue-100 p-6 flex items-center space-x-4">
                    <div class="p-3 bg-cyan-100 rounded-full text-cyan-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z" />
                        </svg>
                    </div>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Current Storage</p>
                        <h2 id="total-capacity" class="text-2xl font-bold text-gray-900">-- MCM</h2>
                    </div>
                </div>

                <!-- Last Update Card -->
                <div class="bg-white rounded-xl shadow-sm border border-blue-100 p-6 flex items-center space-x-4">
                    <div class="p-3 bg-indigo-100 rounded-full text-indigo-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                    </div>
                    <div>
                        <p class="text-sm font-medium text-gray-500">Last Updated</p>
                        <h2 id="last-updated" class="text-lg font-bold text-gray-900">--</h2>
                    </div>
                </div>
            </div>

            <!-- Chart Section -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Main Water Level Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[400px] lg:col-span-2 relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Total Water Storage History</h3>
                    <div class="h-[320px]">
                        <canvas id="waterLevelChart"></canvas>
                    </div>
                </div>

                <!-- Daily Inflows Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[400px] lg:col-span-2 relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Daily Inflows (Current Month)</h3>
                    <div class="h-[320px]">
                        <canvas id="dailyInflowsChart"></canvas>
                    </div>
                </div>

                <!-- Monthly Inflows Comparison Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[400px] lg:col-span-2 relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Monthly Inflows Comparison (Last 6 Years)</h3>
                    <div class="h-[320px]">
                        <canvas id="monthlyComparisonChart"></canvas>
                    </div>
                </div>

                <!-- Dams Breakdown Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[400px] relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Dam Storage Breakdown (MCM)</h3>
                    <div class="h-[320px]">
                        <canvas id="damsChart"></canvas>
                    </div>
                </div>

                <!-- Annual Inflows Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[400px] relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Annual Inflows (MCM)</h3>
                    <div class="h-[320px]">
                        <canvas id="inflowsChart"></canvas>
                    </div>
                </div>

                <!-- Dams Map -->
                <div class="bg-white rounded-xl shadow-lg border border-blue-50 p-6 h-[500px] lg:col-span-2 relative">
                    <h3 class="text-lg font-semibold text-gray-700 mb-4">Reservoir Locations & Status</h3>
                    <div id="damsMap" class="h-[420px] rounded-lg z-0"></div>
                </div>
            </div>
            
            <!-- About Section -->
            <div class="bg-blue-900 text-blue-50 rounded-xl shadow-lg p-8 mt-12">
                <div class="max-w-3xl mx-auto text-center space-y-4">
                    <h2 class="text-2xl font-bold text-white">About This Project</h2>
                    <p class="leading-relaxed text-blue-100">
                        This dashboard provides a comprehensive real-time view of Cyprus's water resources. 
                        By aggregating data from official sources, we aim to offer transparent insights into the island's water security, 
                        tracking reservoir levels, daily inflows, and historical trends to help visualize the impact of seasonal changes and droughts.
                    </p>
                </div>
            </div>
            
            <footer class="text-center text-gray-500 text-sm mt-12 pb-8 space-y-2">
                <p>Developed by <a href="https://e1plus.de" target="_blank" class="text-blue-600 hover:text-blue-800 font-medium">e1+</a></p>
                <div class="text-xs text-gray-400 space-x-2">
                    <span>Special thanks to:</span>
                    <a href="https://www.moa.gov.cy/moa/wdd/wdd.nsf/index_en/index_en?opendocument" target="_blank" class="hover:text-blue-500 underline">Cyprus Water Development Department</a>
                    <span>&bull;</span>
                    <a href="https://cyprus-water.appspot.com/guide" target="_blank" class="hover:text-blue-500 underline">Cyprus Water API</a>
                    <span>by</span>
                    <a href="https://github.com/nearchos" target="_blank" class="hover:text-blue-500 underline">@nearchos</a>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // API Endpoints
        const API_URL_TIMESERIES = 'https://cyprus-water.appspot.com/api/timeseries';
        const API_URL_DAMS = 'https://cyprus-water.appspot.com/api/dams';
        const API_URL_STATS = 'https://cyprus-water.appspot.com/api/date-statistics';
        const API_URL_INFLOWS = 'https://cyprus-water.appspot.com/api/monthly-inflows';

        // DOM Elements
        const loadingEl = document.getElementById('loading');
        const dashboardEl = document.getElementById('dashboard');
        const errorEl = document.getElementById('error');
        const errorMessageEl = document.getElementById('error-message');
        
        const currentPercentageEl = document.getElementById('current-percentage');
        const totalCapacityEl = document.getElementById('total-capacity');
        const lastUpdatedEl = document.getElementById('last-updated');

        // Helper to format numbers
        const formatNumber = (num) => {
            return new Intl.NumberFormat('en-US').format(num);
        };

        // Helper to format date
        const formatDate = (dateStr) => {
            const date = new Date(dateStr);
            return new Intl.DateTimeFormat('en-GB', {
                day: 'numeric',
                month: 'short',
                year: 'numeric'
            }).format(date);
        };

        async function initDashboard() {
            try {
                // 1. Critical: Top Stats & History Chart
                // We fetch this first to show the most important data immediately
                await fetchAndRenderTimeseries();

                // Show Dashboard immediately
                loadingEl.classList.add('hidden');
                dashboardEl.classList.remove('hidden');

                // 2. Secondary: Daily Inflows (Middle section)
                // Fetched sequentially to prioritize bandwidth for top content
                try {
                    await fetchAndRenderDailyInflows();
                } catch (err) {
                    console.warn('Failed to load daily inflows:', err);
                }

                // 3. Tertiary: Bottom Charts
                // These can be fetched in parallel as they are lower down
                Promise.all([
                    fetchAndRenderInflows(),
                    fetchAndRenderDams()
                ]).catch(err => console.warn('Failed to load bottom charts:', err));

            } catch (error) {
                // Critical failure (only if top section fails)
                console.error('Error fetching data:', error);
                loadingEl.classList.add('hidden');
                errorEl.classList.remove('hidden');
                errorMessageEl.textContent = `Error loading data: ${error.message}`;
            }
        }

        async function fetchAndRenderTimeseries() {
            const response = await fetch(API_URL_TIMESERIES);
            if (!response.ok) throw new Error(`Timeseries API error: ${response.status}`);
            const data = await response.json();

            if (!data.percentages || Object.keys(data.percentages).length === 0) {
                throw new Error('No timeseries data available');
            }

            // Process Data
            const timeseriesData = Object.entries(data.percentages).map(([key, value]) => {
                return {
                    date: key,
                    percentage: value.totalPercentage * 100,
                    capacity: value.totalCapacityInMCM
                };
            });

            const sortedData = timeseriesData.sort((a, b) => new Date(a.date) - new Date(b.date));
            const latestEntry = sortedData[sortedData.length - 1];

            // Update Stats Cards
            currentPercentageEl.textContent = `${latestEntry.percentage.toFixed(1)}%`;
            
            totalCapacityEl.innerHTML = latestEntry.capacity 
                ? `${formatNumber(Math.round(latestEntry.capacity))} <abbr title="Million Cubic Meters" class="text-xl text-gray-500 no-underline cursor-help">MCM</abbr>` 
                : 'N/A';
            
            lastUpdatedEl.textContent = formatDate(latestEntry.date);

            // Render Chart
            renderTimeseriesChart(sortedData);
        }

        async function fetchAndRenderDams() {
            const [damsResponse, statsResponse] = await Promise.all([
                fetch(API_URL_DAMS),
                fetch(API_URL_STATS)
            ]);

            if (!damsResponse.ok) throw new Error(`Dams API error: ${damsResponse.status}`);
            if (!statsResponse.ok) throw new Error(`Stats API error: ${statsResponse.status}`);

            const damsData = await damsResponse.json();
            const statsData = await statsResponse.json();

            // Merge Data: Create an array of dams with Name, Capacity, Current Storage
            const processedDams = damsData.map(dam => {
                // Determine the key used in statsData.storageInMCM (usually nameEn)
                // statsData.storageInMCM keys match dam.nameEn mostly
                const currentStorage = statsData.storageInMCM[dam.nameEn] || 0;
                // Capacity in API is in cubic meters, convert to MCM
                const capacityMCM = dam.capacity / 1000000;
                
                return {
                    name: dam.nameEn,
                    capacity: capacityMCM,
                    current: currentStorage,
                    percentage: (currentStorage / capacityMCM) * 100,
                    lat: dam.lat,
                    lng: dam.lng
                };
            });

            // Render Map with all dams (before sorting/slicing)
            renderMap(processedDams);

            // Sort by Capacity descending
            processedDams.sort((a, b) => b.capacity - a.capacity);

            // Take top 15 to avoid overcrowding if there are many
            const topDams = processedDams.slice(0, 15);

            renderDamsChart(topDams);
        }

        function renderMap(dams) {
            // Initialize map centered on Cyprus
            const map = L.map('damsMap').setView([35.0, 33.2], 9);

            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(map);

            dams.forEach(dam => {
                if (dam.lat && dam.lng) {
                    // Determine color based on percentage
                    let color = '#ef4444'; // Red (< 30%)
                    if (dam.percentage >= 60) color = '#22c55e'; // Green
                    else if (dam.percentage >= 30) color = '#eab308'; // Yellow

                    // Create marker circle
                    const circle = L.circleMarker([dam.lat, dam.lng], {
                        radius: 8 + (Math.sqrt(dam.capacity) / 2), // Size proportional to capacity
                        fillColor: color,
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(map);

                    // Popup content
                    const popupContent = `
                        <div class="font-sans">
                            <h3 class="font-bold text-lg mb-1">${dam.name}</h3>
                            <div class="space-y-1 text-sm">
                                <p><strong>Level:</strong> ${dam.percentage.toFixed(1)}%</p>
                                <p><strong>Storage:</strong> ${dam.current.toFixed(2)} MCM</p>
                                <p><strong>Capacity:</strong> ${dam.capacity.toFixed(2)} MCM</p>
                            </div>
                        </div>
                    `;

                    circle.bindPopup(popupContent);
                }
            });
        }

        async function fetchAndRenderInflows() {
            const response = await fetch(API_URL_INFLOWS);
            if (!response.ok) throw new Error(`Inflows API error: ${response.status}`);
            const data = await response.json();

            // Aggregate by Year
            const inflowsByYear = data.reduce((acc, curr) => {
                const year = curr.year;
                if (!acc[year]) acc[year] = 0;
                acc[year] += curr.inflowInMCM;
                return acc;
            }, {});

            const chartData = Object.entries(inflowsByYear)
                .map(([year, total]) => ({ year, total }))
                .sort((a, b) => a.year - b.year);

            renderInflowsChart(chartData);
            renderMonthlyComparisonChart(data);
        }

        async function fetchAndRenderDailyInflows() {
            const today = new Date();
            const year = today.getFullYear();
            const month = today.getMonth(); // 0-indexed
            const days = [];

            // Generate dates from 1st to today
            // Note: API might not have data for today yet, but we check anyway
            for (let d = 1; d <= today.getDate(); d++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
                days.push(dateStr);
            }

            // Fetch all days in parallel
            // Note: This makes multiple requests. 
            const requests = days.map(date => 
                fetch(`${API_URL_STATS}?date=${date}`)
                    .then(res => {
                        if (!res.ok) throw new Error('Network response was not ok');
                        return res.json();
                    })
                    .catch(err => {
                        console.warn(`Failed to fetch stats for ${date}`, err);
                        return null;
                    })
            );

            const results = await Promise.all(requests);
            
            // Process results
            // Filter out failures and deduplicate dates (API returns latest available if requested is future/missing)
            const seenDates = new Set();
            const dailyData = [];

            results.forEach(data => {
                if (!data || !data.date) return;
                
                // data.date format example: "Jan 12, 2026 12:00:00 AM"
                // We normalize it to avoid duplicates
                const dateObj = new Date(data.date);
                const dateKey = dateObj.toDateString(); // "Mon Jan 12 2026"

                // Only sum inflow if we haven't seen this date yet
                // AND the date belongs to the current month (in case API returns old data for start of month requests - unlikely but safe)
                if (!seenDates.has(dateKey) && dateObj.getMonth() === month && dateObj.getFullYear() === year) {
                    seenDates.add(dateKey);
                    
                    let totalInflow = 0;
                    if (data.inflowInMCM) {
                        totalInflow = Object.values(data.inflowInMCM).reduce((a, b) => a + b, 0);
                    }

                    dailyData.push({
                        date: dateObj,
                        inflow: totalInflow
                    });
                }
            });

            // Sort by date
            dailyData.sort((a, b) => a.date - b.date);

            renderDailyInflowsChart(dailyData);
        }

        function renderDailyInflowsChart(data) {
            const ctx = document.getElementById('dailyInflowsChart').getContext('2d');
            
            const labels = data.map(d => d.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }));
            const values = data.map(d => d.inflow);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Daily Inflow',
                        data: values,
                        backgroundColor: 'rgba(16, 185, 129, 0.7)', // Emerald-500
                        borderRadius: 4,
                        barPercentage: 0.6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#1e293b',
                            bodyColor: '#1e293b',
                            borderColor: '#e2e8f0',
                            borderWidth: 1,
                            padding: 10,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `Inflow: ${context.parsed.y.toFixed(3)} MCM`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#64748b',
                                maxTicksLimit: 8, // Reduce labels for mobile
                                maxRotation: 0
                            } 
                        },
                        y: { 
                            grid: { color: '#f1f5f9' }, 
                            ticks: { color: '#94a3b8' },
                            title: { display: true, text: 'MCM' }
                        }
                    }
                }
            });
        }

        function renderMonthlyComparisonChart(rawData) {
            const ctx = document.getElementById('monthlyComparisonChart').getContext('2d');
            
            // Find the latest year
            const maxYear = Math.max(...rawData.map(d => d.year));
            const yearsToShow = [maxYear, maxYear - 1, maxYear - 2, maxYear - 3, maxYear - 4, maxYear - 5];
            
            // Prepare datasets
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const datasets = [];
            
            // Colors for the years (Current year is standout Blue, others are distinct)
            const colors = [
                { border: 'rgb(37, 99, 235)', bg: 'rgba(37, 99, 235, 0.1)', width: 3 }, // Current
                { border: 'rgb(100, 116, 139)', bg: 'transparent', width: 2 }, // Last Year (Slate-500)
                { border: 'rgb(148, 163, 184)', bg: 'transparent', width: 2, dash: [5, 5] }, // -2 (Slate-400)
                { border: 'rgb(203, 213, 225)', bg: 'transparent', width: 2, dash: [5, 5] }, // -3 (Slate-300)
                { border: 'rgb(226, 232, 240)', bg: 'transparent', width: 1, dash: [2, 2] }, // -4
                { border: 'rgb(241, 245, 249)', bg: 'transparent', width: 1, dash: [2, 2] }  // -5
            ];

            // Better palette for comparison:
            const palette = [
                'rgb(37, 99, 235)',   // Blue (Current)
                'rgb(234, 88, 12)',   // Orange
                'rgb(22, 163, 74)',   // Green
                'rgb(147, 51, 234)',  // Purple
                'rgb(219, 39, 119)',  // Pink
                'rgb(71, 85, 105)'    // Slate
            ];

            yearsToShow.forEach((year, index) => {
                // Filter data for this year and sort by month index
                const yearData = rawData
                    .filter(d => d.year === year)
                    .sort((a, b) => a.periodOrder - b.periodOrder);
                
                // Map to 12 months array (fill missing with null)
                const dataPoints = new Array(12).fill(null);
                yearData.forEach(d => {
                    // periodOrder is 1-12, array is 0-11
                    if (d.periodOrder >= 1 && d.periodOrder <= 12) {
                        dataPoints[d.periodOrder - 1] = d.inflowInMCM;
                    }
                });

                datasets.push({
                    label: year.toString(),
                    data: dataPoints,
                    borderColor: palette[index],
                    backgroundColor: 'transparent',
                    borderWidth: index === 0 ? 3 : 2, // Thicker for current year
                    tension: 0.3,
                    pointRadius: index === 0 ? 4 : 2,
                    pointHoverRadius: 6
                });
            });

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: months,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            bottom: 20
                        }
                    },
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { 
                            position: 'top', 
                            align: 'center', 
                            labels: {
                                boxWidth: 8,
                                padding: 8,
                                usePointStyle: true,
                                font: {
                                    size: 11
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#1e293b',
                            bodyColor: '#1e293b',
                            borderColor: '#e2e8f0',
                            borderWidth: 1,
                            padding: 10,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2) + ' MCM';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#64748b',
                                maxRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 6,
                                font: {
                                    size: 11
                                }
                            } 
                        },
                        y: { 
                            grid: { color: '#f1f5f9' }, 
                            ticks: { color: '#94a3b8' },
                            title: { display: true, text: 'Inflow (MCM)' }
                        }
                    }
                }
            });
        }

        function renderTimeseriesChart(data) {
            const ctx = document.getElementById('waterLevelChart').getContext('2d');
            
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            gradient.addColorStop(0, 'rgba(37, 99, 235, 0.5)'); 
            gradient.addColorStop(1, 'rgba(37, 99, 235, 0.0)');

            const dates = data.map(item => formatDate(item.date));
            const percentages = data.map(item => item.percentage);

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'Water Level (%)',
                        data: percentages,
                        borderColor: 'rgb(37, 99, 235)',
                        backgroundColor: gradient,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 6,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#1e293b',
                            bodyColor: '#1e293b',
                            borderColor: '#e2e8f0',
                            borderWidth: 1,
                            padding: 10,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `Level: ${context.parsed.y.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { maxTicksLimit: 8, color: '#94a3b8' } },
                        y: { 
                            min: 0, max: 100, 
                            grid: { color: '#f1f5f9' }, 
                            ticks: { callback: v => v + '%', color: '#94a3b8' } 
                        }
                    }
                }
            });
        }

        function renderDamsChart(data) {
            const ctx = document.getElementById('damsChart').getContext('2d');
            
            const labels = data.map(d => d.name);
            const currentData = data.map(d => d.current);
            const capacityData = data.map(d => d.capacity);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Current Storage',
                            data: currentData,
                            backgroundColor: 'rgba(37, 99, 235, 0.8)',
                            borderRadius: 4,
                        },
                        {
                            label: 'Total Capacity',
                            data: capacityData,
                            backgroundColor: 'rgba(203, 213, 225, 0.5)',
                            borderRadius: 4,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'top', align: 'end' },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#1e293b',
                            bodyColor: '#1e293b',
                            borderColor: '#e2e8f0',
                            borderWidth: 1,
                            padding: 10,
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} MCM`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#64748b', 
                                font: { size: 10 }, // Slightly smaller for mobile
                                autoSkip: false, // Force show all top dams
                                maxRotation: 90,
                                minRotation: 45 
                            } 
                        },
                        y: { 
                            grid: { color: '#f1f5f9' }, 
                            ticks: { color: '#94a3b8' },
                            title: { display: true, text: 'MCM' }
                        }
                    }
                }
            });
        }

        function renderInflowsChart(data) {
            const ctx = document.getElementById('inflowsChart').getContext('2d');
            
            const labels = data.map(d => d.year);
            const values = data.map(d => d.total);

            // Color logic: Highlight recent years or just uniform
            const backgroundColors = values.map(v => 'rgba(14, 165, 233, 0.7)'); // Sky-500

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Annual Inflow',
                        data: values,
                        backgroundColor: backgroundColors,
                        borderRadius: 4,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.9)',
                            titleColor: '#1e293b',
                            bodyColor: '#1e293b',
                            borderColor: '#e2e8f0',
                            borderWidth: 1,
                            padding: 10,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    return `Inflow: ${context.parsed.y.toFixed(1)} MCM`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { 
                                color: '#64748b',
                                maxTicksLimit: 10 // Limit years on small screens
                            } 
                        },
                        y: { 
                            grid: { color: '#f1f5f9' }, 
                            ticks: { color: '#94a3b8' },
                            title: { display: true, text: 'MCM' }
                        }
                    }
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>